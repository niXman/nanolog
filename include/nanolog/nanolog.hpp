
// Copyright (c) 2015-2019 niXman (i dot nixman dog gmail dot com). All
// rights reserved.
//
// This file is part of NANOLOG(https://github.com/niXman/nanolog) project.
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
//
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef __NANOLOG__NANOLOG_HPP__INCLUDED
#define __NANOLOG__NANOLOG_HPP__INCLUDED

#ifndef NNL_DISABLE_LOGGING

/***************************************************************************/

#if !defined(NNL_USE_PRINTF) && !defined(NNL_USE_BOOST_FORMAT)
#  define NNL_USE_PRINTF
#endif

#include <cassert>

#if defined(NNL_USE_PRINTF)
#  include <cstdio>
#  define __NNL_STREAM_TYPE ::std::FILE*
#elif defined(NNL_USE_BOOST_FORMAT)
#  include <boost/format.hpp>
#  include <fstream>
#  define __NNL_STREAM_TYPE ::std::ostream&
#else
#  error please define one of NNL_USE_PRINTF or NNL_USE_BOOST_FORMAT
#endif // NNL_USE_PRINTF

#if !defined(NNL_SHORT_FILEPATH)
#  define __NNL_FILEPATH(file) file
#else
#  include <cstring>
#  ifdef _WIN32
#     define __NNL_FILEPATH_SEP '\\'
#  else
#     define __NNL_FILEPATH_SEP '/'
#  endif // _WIN32
#  define __NNL_FILEPATH(file) (std::strrchr(file, __NNL_FILEPATH_SEP)+1)
#endif // NNL_SHORT_FILEPATH

#ifdef NNL_USE_DATETIME
#  include <ctime>

#  define NNL_DATE_FORMAT_DMY (0) // day.month.year
#  define NNL_DATE_FORMAT_YMD (1) // year.month.day
#  define NNL_DATE_FORMAT_MDY (2) // month.day.year

#  ifndef NNL_DATE_FORMAT
#    define NNL_DATE_FORMAT NNL_DATE_FORMAT_YMD
#  endif // NNL_DATE_FORMAT

#  if !(NNL_DATE_FORMAT == NNL_DATE_FORMAT_DMY || \
        NNL_DATE_FORMAT == NNL_DATE_FORMAT_YMD || \
        NNL_DATE_FORMAT == NNL_DATE_FORMAT_MDY)
#    error "bad NNL_DATE_FORMAT"
#  endif
#endif // NNL_USE_DATETIME

/***************************************************************************/

#define __NNL_ARG16(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, ...) _15
#define __NNL_HAS_COMMA(...) __NNL_ARG16(__VA_ARGS__, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0)
#define __NNL__TRIGGER_PARENTHESIS_(...) ,
#define __NNL_PASTE5(_0, _1, _2, _3, _4) _0 ## _1 ## _2 ## _3 ## _4
#define __NNL__IS_EMPTY_CASE_0001 ,
#define __NNL__IS_EMPTY(_0, _1, _2, _3) __NNL_HAS_COMMA(__NNL_PASTE5(__NNL__IS_EMPTY_CASE_, _0, _1, _2, _3))

#define __NNL_TUPLE_IS_EMPTY(...) \
  __NNL__IS_EMPTY( \
    __NNL_HAS_COMMA(__VA_ARGS__), \
    __NNL_HAS_COMMA(__NNL__TRIGGER_PARENTHESIS_ __VA_ARGS__), \
    __NNL_HAS_COMMA(__VA_ARGS__ (/*empty*/)), \
    __NNL_HAS_COMMA(__NNL__TRIGGER_PARENTHESIS_ __VA_ARGS__ (/*empty*/)) \
  )

/***************************************************************************/

#define __NNL_IIF(bit, t, f) __NNL_IIF_I(bit, t, f)
#define __NNL_IIF_I(bit, t, f) __NNL_IIF_ ## bit(t, f)
#define __NNL_IIF_0(t, f) f
#define __NNL_IIF_1(t, f) t
#define __NNL_IF(cond, t, f) __NNL_IIF(cond, t, f)

#define ___NNL_STRINGIZE(x) #x
#define __NNL_STRINGIZE(x) ___NNL_STRINGIZE(x)

#define __NNL_CAT_I(a, b) a ## b
#define __NNL_CAT(a, b) __NNL_CAT_I(a, b)

#define __NNL_NARG(...) \
  __NNL_NARG_(__VA_ARGS__,__NNL_RSEQ_N())
#define __NNL_NARG_(...) \
  __NNL_ARG_N(__VA_ARGS__)
#define __NNL_ARG_N( \
  _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \
  _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \
  _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \
  _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \
  _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \
  _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \
  _61,_62,_63,N,...) N
#define __NNL_RSEQ_N() \
  63,62,61,60,                   \
  59,58,57,56,55,54,53,52,51,50, \
  49,48,47,46,45,44,43,42,41,40, \
  39,38,37,36,35,34,33,32,31,30, \
  29,28,27,26,25,24,23,22,21,20, \
  19,18,17,16,15,14,13,12,11,10, \
  9,8,7,6,5,4,3,2,1,0

#define __NNL_ENUM_CP_ARGS_0()
#define __NNL_ENUM_CP_ARGS_1(_1) ,(_1)
#define __NNL_ENUM_CP_ARGS_2(_1, _2) \
  __NNL_ENUM_CP_ARGS_1(_1) __NNL_ENUM_CP_ARGS_1(_2)
#define __NNL_ENUM_CP_ARGS_3(_1, _2, _3) \
  __NNL_ENUM_CP_ARGS_2(_1, _2) __NNL_ENUM_CP_ARGS_1(_3)
#define __NNL_ENUM_CP_ARGS_4(_1, _2, _3, _4) \
  __NNL_ENUM_CP_ARGS_3(_1, _2, _3) __NNL_ENUM_CP_ARGS_1(_4)
#define __NNL_ENUM_CP_ARGS_5(_1, _2, _3, _4, _5) \
  __NNL_ENUM_CP_ARGS_4(_1, _2, _3, _4) __NNL_ENUM_CP_ARGS_1(_5)
#define __NNL_ENUM_CP_ARGS_6(_1, _2, _3, _4, _5, _6) \
  __NNL_ENUM_CP_ARGS_5(_1, _2, _3, _4, _5) __NNL_ENUM_CP_ARGS_1(_6)
#define __NNL_ENUM_CP_ARGS_7(_1, _2, _3, _4, _5, _6, _7) \
  __NNL_ENUM_CP_ARGS_6(_1, _2, _3, _4, _5, _6) __NNL_ENUM_CP_ARGS_1(_7)
#define __NNL_ENUM_CP_ARGS_8(_1, _2, _3, _4, _5, _6, _7, _8) \
  __NNL_ENUM_CP_ARGS_7(_1, _2, _3, _4, _5, _6, _7) __NNL_ENUM_CP_ARGS_1(_8)
#define __NNL_ENUM_CP_ARGS_9(_1, _2, _3, _4, _5, _6, _7, _8, _9) \
  __NNL_ENUM_CP_ARGS_8(_1, _2, _3, _4, _5, _6, _7, _8) __NNL_ENUM_CP_ARGS_1(_9)

#define __NNL_ENUM_CP_ARGS_IMPL(n, ...) \
  __NNL_CAT(__NNL_ENUM_CP_ARGS_, n)(__VA_ARGS__)
#define __NNL_ENUM_CP_ARGS(...) \
  __NNL_ENUM_CP_ARGS_IMPL(__NNL_NARG(__VA_ARGS__), __VA_ARGS__)

#define __NNL_ENUM_BF_ARGS_0()
#define __NNL_ENUM_BF_ARGS_1(_1) % (_1)
#define __NNL_ENUM_BF_ARGS_2(_1, _2) \
  __NNL_ENUM_BF_ARGS_1(_1) __NNL_ENUM_BF_ARGS_1(_2)
#define __NNL_ENUM_BF_ARGS_3(_1, _2, _3) \
  __NNL_ENUM_BF_ARGS_2(_1, _2) __NNL_ENUM_BF_ARGS_1(_3)
#define __NNL_ENUM_BF_ARGS_4(_1, _2, _3, _4) \
  __NNL_ENUM_BF_ARGS_3(_1, _2, _3) __NNL_ENUM_BF_ARGS_1(_4)
#define __NNL_ENUM_BF_ARGS_5(_1, _2, _3, _4, _5) \
  __NNL_ENUM_BF_ARGS_4(_1, _2, _3, _4) __NNL_ENUM_BF_ARGS_1(_5)
#define __NNL_ENUM_BF_ARGS_6(_1, _2, _3, _4, _5, _6) \
  __NNL_ENUM_BF_ARGS_5(_1, _2, _3, _4, _5) __NNL_ENUM_BF_ARGS_1(_6)
#define __NNL_ENUM_BF_ARGS_7(_1, _2, _3, _4, _5, _6, _7) \
  __NNL_ENUM_BF_ARGS_6(_1, _2, _3, _4, _5, _6) __NNL_ENUM_BF_ARGS_1(_7)
#define __NNL_ENUM_BF_ARGS_8(_1, _2, _3, _4, _5, _6, _7, _8) \
  __NNL_ENUM_BF_ARGS_7(_1, _2, _3, _4, _5, _6, _7) __NNL_ENUM_BF_ARGS_1(_8)
#define __NNL_ENUM_BF_ARGS_9(_1, _2, _3, _4, _5, _6, _7, _8, _9) \
  __NNL_ENUM_BF_ARGS_8(_1, _2, _3, _4, _5, _6, _7, _8) __NNL_ENUM_BF_ARGS_1(_9)

#define __NNL_ENUM_BF_ARGS_IMPL(n, ...) \
  __NNL_CAT(__NNL_ENUM_BF_ARGS_, n)(__VA_ARGS__)
#define __NNL_ENUM_BF_ARGS(...) \
  __NNL_ENUM_BF_ARGS_IMPL(__NNL_NARG(__VA_ARGS__), __VA_ARGS__)

/***************************************************************************/

#define __NNL_FMT_ERROR_LVL(lvl) ("IDWE"[lvl])

#ifdef NNL_USE_DATETIME
#  define  __NNL_MAKE_FMT_STRING() \
     "%s(%-4d)[%c][%-23s]: "
#  define  __NNL_MAKE_DATETIME_BUF() \
     char dtbuf[24]; \
     dtbuf[23] = 0;
#  if defined(NNL_USE_PRINTF)
#    define  __NNL_MAKE_FMT_STRING_ARGS(file, line, lvl) \
       __NNL_FILEPATH(file), line, \
         __NNL_FMT_ERROR_LVL(lvl), ::NNL::datetime_str(dtbuf)
#  else // !NNL_USE_PRINTF
#    define  __NNL_MAKE_FMT_STRING_ARGS(file, line, lvl) \
       % __NNL_FILEPATH(file) % line \
         % __NNL_FMT_ERROR_LVL(lvl) % ::NNL::datetime_str(dtbuf)
#  endif // NNL_USE_PRINTF
#else // !NNL_USE_DATETIME
#  define  __NNL_MAKE_FMT_STRING() \
     "%s(%-4d)[%c]: "
#  define  __NNL_MAKE_DATETIME_BUF()
#  if defined(NNL_USE_PRINTF)
#    define  __NNL_MAKE_FMT_STRING_ARGS(file, line, lvl) \
       __NNL_FILEPATH(file), line, __NNL_FMT_ERROR_LVL(lvl)
#  else // !NNL_USE_PRINTF
#    define  __NNL_MAKE_FMT_STRING_ARGS(file, line, lvl) \
       % __NNL_FILEPATH(file) % line % __NNL_FMT_ERROR_LVL(lvl)
#  endif // NNL_USE_PRINTF
#endif // NNL_USE_DATETIME

/***************************************************************************/

namespace NNL {

#ifdef NNL_USE_DATETIME

static struct __init {
  __init() {
    std::time_t t = time(0);
    std::tm *lt = localtime(&t);
    (void)lt;
  }
} __g_init;

inline const char* datetime_str(char *buf) {
  struct ops {
    static long long abs(long long v) { return v < 0 ? -v : v; }

    static std::size_t itoa(char *ptr, long long v) {
      if ( v < 0 ) { *ptr++ = '-'; }
      long long t = v = abs(v);

      std::size_t len = 1;
      if ( t >= 10000000000000000ll ) { len += 16; t /= 10000000000000000ll; }
      if ( t >= 100000000 ) { len += 8; t /= 100000000; }
      if ( t >= 10000 ) { len += 4; t /= 10000; }
      if ( t >= 100 ) { len += 2; t /= 100; }
      if ( t >= 10 ) { len += 1; }

      char *p = ptr+len-1;
      switch ( len ) {
        case 20: *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 19: *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 18: *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 17: *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 16: *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 15: *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 14: *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 13: *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 12: *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 11: *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 10: *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 9 : *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 8 : *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 7 : *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 6 : *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 5 : *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 4 : *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 3 : *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 2 : *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
        case 1 : *p-- = static_cast<char>('0'+(v % 10)); v /= 10; // fallthrough
      }
      return len;
    }

    static std::tm* time_t_to_tm(const std::time_t t, std::tm *r) {
      static const short spm[13] = {
         0
        ,(31)
        ,(31+28)
        ,(31+28+31)
        ,(31+28+31+30)
        ,(31+28+31+30+31)
        ,(31+28+31+30+31+30)
        ,(31+28+31+30+31+30+31)
        ,(31+28+31+30+31+30+31+31)
        ,(31+28+31+30+31+30+31+31+30)
        ,(31+28+31+30+31+30+31+31+30+31)
        ,(31+28+31+30+31+30+31+31+30+31+30)
        ,(31+28+31+30+31+30+31+31+30+31+30+31)
      };
      static const int SPD = 24*60*60; // seconds per day
      time_t i = 1970, work = t % SPD;
      r->tm_sec = work % 60;
      work /= 60;
      r->tm_min = work % 60;
      r->tm_hour = work / 60;
      work = t / SPD;
      r->tm_wday = (4+work) % 7;
      for ( ; ; ++i ) {
        const time_t k = (!(i % 4) && ((i % 100) || !(i % 400))) ? 366 : 365;
        if ( work >= k )
          work -= k;
        else
          break;
      }
      r->tm_year = i-1900;
      r->tm_yday = work;

      r->tm_mday = 1;
      if ( (!(i % 4) && ((i % 100) || !(i % 400))) && (work > 58) ) {
        if ( work == 59 )
          r->tm_mday = 2;
        work -= 1;
      }

      for (i = 11; i && (spm[i] > work); --i )
        ;

      r->tm_mon = i;
      r->tm_mday += work - spm[i];

      return r;
    }

    static std::size_t datetime_str(char *ptr) {
      char *p = ptr;
      struct timespec ts;
      clock_gettime(CLOCK_REALTIME, &ts);
      std::tm tm;
      time_t_to_tm(ts.tv_sec, &tm);
      tm.tm_hour += abs(timezone/(60*60));

#define __NNL_YEAR(p, tm) \
      *p++ = ((tm.tm_year+1900)/1000)%10+'0'; \
      *p++ = ((tm.tm_year+1900)/100)%10+'0'; \
      *p++ = ((tm.tm_year+1900)/10)%10+'0'; \
      *p++ = (tm.tm_year+1900)%10+'0';
#define __NNL_MONTH(p, tm) \
      *p++ = ((tm.tm_mon+1)/10)%10+'0'; \
      *p++ = (tm.tm_mon+1)%10+'0';
#define __NNL_DAY(p, tm) \
      *p++ = (tm.tm_mday/10)%10+'0'; \
      *p++ = tm.tm_mday%10+'0';

#if NNL_DATE_FORMAT == NNL_DATE_FORMAT_DMY // day.month.year
      // day
      __NNL_DAY(p, tm)
      /* sep */
      *p++ = '.';
      // month
      __NNL_MONTH(p, tm)
      /* sep */
      *p++ = '.';
      // year
      __NNL_YEAR(p, tm)
#elif NNL_DATE_FORMAT == NNL_DATE_FORMAT_YMD // year.month.day
      // year
      __NNL_YEAR(p, tm)
      /* sep */
      *p++ = '.';
      // month
      __NNL_MONTH(p, tm)
      /* sep */
      *p++ = '.';
      // day
      __NNL_DAY(p, tm)
#else                                       // month.day.year
      // month
      __NNL_MONTH(p, tm)
      /* sep */
      *p++ = '.';
      // day
      __NNL_DAY(p, tm)
      /* sep */
      *p++ = '.';
      // year
      __NNL_YEAR(p, tm)
#endif // NNL_DATE_FORMAT

#undef __NNL_YEAR
#undef __NNL_MONTH
#undef __NNL_DAY

      /* sep */
      *p++ = '-';
      // hours
      *p++ = (tm.tm_hour/10)%10+'0';
      *p++ = tm.tm_hour%10+'0';
      /* sep */
      *p++ = ':';
      // minutes
      *p++ = (tm.tm_min/10)%10+'0';
      *p++ = tm.tm_min%10+'0';
      /* sep */
      *p++ = ':';
      // seconds
      *p++ = (tm.tm_sec/10)%10+'0';
      *p++ = tm.tm_sec%10+'0';
      /* sep */
      // microseconds
      *p++ = '.';
      p += itoa(p, ts.tv_nsec/1000000);

      return p-ptr;
    }
  };

  ops::datetime_str(buf);

  return buf;
}

#endif // NNL_USE_DATETIME

enum elevel {
   info
  ,debug
  ,warning
  ,error
};

} // ns NNL

/***************************************************************************/

#if defined(NNL_USE_PRINTF)
#  if defined(NNL_FLUSH_EACH_RECORD)
#    define __NNL_FLUSH_FUNC(os) ::std::fflush(os);
#  else
#    define __NNL_FLUSH_FUNC(os)
#  endif
#  define __NNL_CREATE_LOG_STREAM(sname, path) \
     ::std::FILE *sname = ::std::fopen(path, "a+b"); \
     assert(sname != 0);
#  define __NNL_CLOSE_LOG_STREAM(sname) \
     if ( sname ) { \
       ::std::fclose(sname); \
       sname = 0; \
     }
#else
#  if defined(NNL_FLUSH_EACH_RECORD)
#    define __NNL_FLUSH_FUNC(os) os << ::std::flush;
#  else
#    define __NNL_FLUSH_FUNC(os)
#  endif
#  define __NNL_CREATE_LOG_STREAM(sname, path) \
     ::std::ofstream sname(path, ::std::ios::out|::std::ios::app|::std::ios::binary); \
     assert(sname.is_open());
#  define __NNL_CLOSE_LOG_STREAM(sname) \
     if ( sname.is_open() ) { \
       sname.close(); \
     }
#endif

#if defined(NNL_USE_PRINTF)
#  define __NNL_WITHOUT_ARGS(os, file, line, lvl, fmt, ...) \
     __NNL_MAKE_DATETIME_BUF() \
     ::std::fprintf( \
        os \
       ,__NNL_MAKE_FMT_STRING() "%s" \
       ,__NNL_MAKE_FMT_STRING_ARGS(file, line, lvl) \
       ,fmt \
     );
#  define __NNL_WITH_ARGS(os, file, line, lvl, fmt, ...) \
     __NNL_MAKE_DATETIME_BUF() \
     ::std::fprintf( \
        os \
       ,__NNL_MAKE_FMT_STRING() fmt \
       ,__NNL_MAKE_FMT_STRING_ARGS(file, line, lvl) \
        __NNL_ENUM_CP_ARGS(__VA_ARGS__) \
     );
#else // !NNL_USE_PRINTF
#  define __NNL_WITHOUT_ARGS(os, file, line, lvl, fmt, ...) \
     __NNL_MAKE_DATETIME_BUF() \
       os << ::boost::format(__NNL_MAKE_FMT_STRING() fmt) \
         __NNL_MAKE_FMT_STRING_ARGS(file, line, lvl);
#  define __NNL_WITH_ARGS(os, file, line, lvl, fmt, ...) \
     __NNL_MAKE_DATETIME_BUF() \
       os << ::boost::format(__NNL_MAKE_FMT_STRING() fmt) \
         __NNL_MAKE_FMT_STRING_ARGS(file, line, lvl) \
           __NNL_ENUM_BF_ARGS(__VA_ARGS__);
#endif // NNL_USE_PRINTF

#define __NNL_LOG(os, lvl, fmt, ...) \
  do { \
    __NNL_IF( \
       __NNL_TUPLE_IS_EMPTY(__VA_ARGS__) \
      ,__NNL_WITHOUT_ARGS \
      ,__NNL_WITH_ARGS \
    )(os, __FILE__, __LINE__, lvl, fmt, __VA_ARGS__) \
    \
    __NNL_FLUSH_FUNC(os) \
  } while(0);

# define __NNL_LOGI(os, fmt, ...) __NNL_LOG(os, ::NNL::info, fmt, __VA_ARGS__)
# define __NNL_LOGD(os, fmt, ...) __NNL_LOG(os, ::NNL::debug, fmt, __VA_ARGS__)
# define __NNL_LOGW(os, fmt, ...) __NNL_LOG(os, ::NNL::warning, fmt, __VA_ARGS__)
# define __NNL_LOGE(os, fmt, ...) __NNL_LOG(os, ::NNL::error, fmt, __VA_ARGS__)

/***************************************************************************/

# define NNL_LOGI(os, fmt, ...) __NNL_LOGI(os, fmt, __VA_ARGS__)
# define NNL_LOGD(os, fmt, ...) __NNL_LOGD(os, fmt, __VA_ARGS__)
# define NNL_LOGW(os, fmt, ...) __NNL_LOGW(os, fmt, __VA_ARGS__)
# define NNL_LOGE(os, fmt, ...) __NNL_LOGE(os, fmt, __VA_ARGS__)

# define NNL_LOGI_IF(expr, os, fmt, ...) if (expr) __NNL_LOGI(os, fmt, __VA_ARGS__)
# define NNL_LOGD_IF(expr, os, fmt, ...) if (expr) __NNL_LOGD(os, fmt, __VA_ARGS__)
# define NNL_LOGW_IF(expr, os, fmt, ...) if (expr) __NNL_LOGW(os, fmt, __VA_ARGS__)
# define NNL_LOGE_IF(expr, os, fmt, ...) if (expr) __NNL_LOGE(os, fmt, __VA_ARGS__)

# define NNL_LOG_INFO(os, fmt, ...) __NNL_LOGI(os, fmt, __VA_ARGS__)
# define NNL_LOG_DEBUG(os, fmt, ...) __NNL_LOGD(os, fmt, __VA_ARGS__)
# define NNL_LOG_WARNING(os, fmt, ...) __NNL_LOGW(os, fmt, __VA_ARGS__)
# define NNL_LOG_ERROR(os, fmt, ...) __NNL_LOGE(os, fmt, __VA_ARGS__)

# define NNL_LOG_INFO_IF(expr, os, fmt, ...) if (expr) __NNL_LOGI(os, fmt, __VA_ARGS__)
# define NNL_LOG_DEBUG_IF(expr, os, fmt, ...) if (expr) __NNL_LOGD(os, fmt, __VA_ARGS__)
# define NNL_LOG_WARNING_IF(expr, os, fmt, ...) if (expr) __NNL_LOGW(os, fmt, __VA_ARGS__)
# define NNL_LOG_ERROR_IF(expr, os, fmt, ...) if (expr) __NNL_LOGE(os, fmt, __VA_ARGS__)

# define NNL_CREATE_LOG_STREAM(sname, path) __NNL_CREATE_LOG_STREAM(sname, path)
# define NNL_CLOSE_LOG_STREAM(sname) __NNL_CLOSE_LOG_STREAM(sname)
#else // NNL_DISABLE_LOGGING
# define NNL_LOGI(os, fmt, ...)
# define NNL_LOGD(os, fmt, ...)
# define NNL_LOGW(os, fmt, ...)
# define NNL_LOGE(os, fmt, ...)

# define NNL_LOGI_IF(expr, os, fmt, ...)
# define NNL_LOGD_IF(expr, os, fmt, ...)
# define NNL_LOGW_IF(expr, os, fmt, ...)
# define NNL_LOGE_IF(expr, os, fmt, ...)

# define NNL_LOG_INFO(os, fmt, ...)
# define NNL_LOG_DEBUG(os, fmt, ...)
# define NNL_LOG_WARNING(os, fmt, ...)
# define NNL_LOG_ERROR(os, fmt, ...)

# define NNL_LOG_INFO_IF(expr, os, fmt, ...)
# define NNL_LOG_DEBUG_IF(expr, os, fmt, ...)
# define NNL_LOG_WARNING_IF(expr, os, fmt, ...)
# define NNL_LOG_ERROR_IF(expr, os, fmt, ...)

# define NNL_CREATE_LOG_STREAM(sname, path)
# define NNL_CLOSE_LOG_STREAM(sname)

/***************************************************************************/

#endif // NNL_DISABLE_LOGGING

#endif // __NANOLOG__NANOLOG_HPP__INCLUDED
